immutable是一种持久化数据。一旦被创建就不会被修改。修改immutable对象的时候返回新的immutable。但是原数据不会改变。

在Rudux中因为深拷贝对性能的消耗太大了（用到了递归一次性得到新对象，万一层次太深怎么办，逐层拷贝每个节点）。 但当你使用immutable数据的时候：只会拷贝你改变的节点，从而达到了节省性能。 总结：immutable的不可变性让纯函数更强大，

PureComponent memo都是浅层的比较，也就是说比较了第一层，但是按照shouldComponentUpdate来讲，他们也应该进行递归来比较前后两次的state或props，但是使用这个api就必须要接受这一点，如果有较深层次的比较则可能会导致更严重的性能问题，因此在这种情况下不要靠手动管理组件的重新渲染来优化性能，要找其他方式，也就是数据有可能变了，但是视图没有更新的问题所以我们在设置state的时候，尽可能的不要层级太深

彻底拥抱 "不可变值"


基于共享数据(不是深拷贝) ，速度好

state层级不要深
